/* automatically generated by rust-bindgen */

pub const SPEEX_RESAMPLER_QUALITY_MAX: u32 = 10;
pub const SPEEX_RESAMPLER_QUALITY_MIN: u32 = 0;
pub const SPEEX_RESAMPLER_QUALITY_DEFAULT: u32 = 4;
pub const SPEEX_RESAMPLER_QUALITY_VOIP: u32 = 3;
pub const SPEEX_RESAMPLER_QUALITY_DESKTOP: u32 = 5;
pub type spx_int16_t = ::std::os::raw::c_short;
pub type spx_uint16_t = ::std::os::raw::c_ushort;
pub type spx_int32_t = ::std::os::raw::c_int;
pub type spx_uint32_t = ::std::os::raw::c_uint;
pub const RESAMPLER_ERR_SUCCESS: _bindgen_ty_1 = 0;
pub const RESAMPLER_ERR_ALLOC_FAILED: _bindgen_ty_1 = 1;
pub const RESAMPLER_ERR_BAD_STATE: _bindgen_ty_1 = 2;
pub const RESAMPLER_ERR_INVALID_ARG: _bindgen_ty_1 = 3;
pub const RESAMPLER_ERR_PTR_OVERLAP: _bindgen_ty_1 = 4;
pub const RESAMPLER_ERR_MAX_ERROR: _bindgen_ty_1 = 5;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpeexResamplerState_ {
    _unused: [u8; 0],
}
pub type SpeexResamplerState = SpeexResamplerState_;
extern "C" {
    #[doc = " Create a new resampler with integer input and output rates."]
    #[doc = " @param nb_channels Number of channels to be processed"]
    #[doc = " @param in_rate Input sampling rate (integer number of Hz)."]
    #[doc = " @param out_rate Output sampling rate (integer number of Hz)."]
    #[doc = " @param quality Resampling quality between 0 and 10, where 0 has poor quality"]
    #[doc = " and 10 has very high quality."]
    #[doc = " @return Newly created resampler state"]
    #[doc = " @retval NULL Error: not enough memory"]
    pub fn speex_resampler_init(
        nb_channels: spx_uint32_t,
        in_rate: spx_uint32_t,
        out_rate: spx_uint32_t,
        quality: ::std::os::raw::c_int,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut SpeexResamplerState;
}
extern "C" {
    #[doc = " Create a new resampler with fractional input/output rates. The sampling"]
    #[doc = " rate ratio is an arbitrary rational number with both the numerator and"]
    #[doc = " denominator being 32-bit integers."]
    #[doc = " @param nb_channels Number of channels to be processed"]
    #[doc = " @param ratio_num Numerator of the sampling rate ratio"]
    #[doc = " @param ratio_den Denominator of the sampling rate ratio"]
    #[doc = " @param in_rate Input sampling rate rounded to the nearest integer (in Hz)."]
    #[doc = " @param out_rate Output sampling rate rounded to the nearest integer (in Hz)."]
    #[doc = " @param quality Resampling quality between 0 and 10, where 0 has poor quality"]
    #[doc = " and 10 has very high quality."]
    #[doc = " @return Newly created resampler state"]
    #[doc = " @retval NULL Error: not enough memory"]
    pub fn speex_resampler_init_frac(
        nb_channels: spx_uint32_t,
        ratio_num: spx_uint32_t,
        ratio_den: spx_uint32_t,
        in_rate: spx_uint32_t,
        out_rate: spx_uint32_t,
        quality: ::std::os::raw::c_int,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut SpeexResamplerState;
}
extern "C" {
    #[doc = " Destroy a resampler state."]
    #[doc = " @param st Resampler state"]
    pub fn speex_resampler_destroy(st: *mut SpeexResamplerState);
}
extern "C" {
    #[doc = " Resample a float array. The input and output buffers must *not* overlap."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param channel_index Index of the channel to process for the multi-channel"]
    #[doc = " base (0 otherwise)"]
    #[doc = " @param in Input buffer"]
    #[doc = " @param in_len Number of input samples in the input buffer. Returns the"]
    #[doc = " number of samples processed"]
    #[doc = " @param out Output buffer"]
    #[doc = " @param out_len Size of the output buffer. Returns the number of samples written"]
    pub fn speex_resampler_process_float(
        st: *mut SpeexResamplerState,
        channel_index: spx_uint32_t,
        in_: *const f32,
        in_len: *mut spx_uint32_t,
        out: *mut f32,
        out_len: *mut spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resample an int array. The input and output buffers must *not* overlap."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param channel_index Index of the channel to process for the multi-channel"]
    #[doc = " base (0 otherwise)"]
    #[doc = " @param in Input buffer"]
    #[doc = " @param in_len Number of input samples in the input buffer. Returns the number"]
    #[doc = " of samples processed"]
    #[doc = " @param out Output buffer"]
    #[doc = " @param out_len Size of the output buffer. Returns the number of samples written"]
    pub fn speex_resampler_process_int(
        st: *mut SpeexResamplerState,
        channel_index: spx_uint32_t,
        in_: *const spx_int16_t,
        in_len: *mut spx_uint32_t,
        out: *mut spx_int16_t,
        out_len: *mut spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resample an interleaved float array. The input and output buffers must *not* overlap."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param in Input buffer"]
    #[doc = " @param in_len Number of input samples in the input buffer. Returns the number"]
    #[doc = " of samples processed. This is all per-channel."]
    #[doc = " @param out Output buffer"]
    #[doc = " @param out_len Size of the output buffer. Returns the number of samples written."]
    #[doc = " This is all per-channel."]
    pub fn speex_resampler_process_interleaved_float(
        st: *mut SpeexResamplerState,
        in_: *const f32,
        in_len: *mut spx_uint32_t,
        out: *mut f32,
        out_len: *mut spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resample an interleaved int array. The input and output buffers must *not* overlap."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param in Input buffer"]
    #[doc = " @param in_len Number of input samples in the input buffer. Returns the number"]
    #[doc = " of samples processed. This is all per-channel."]
    #[doc = " @param out Output buffer"]
    #[doc = " @param out_len Size of the output buffer. Returns the number of samples written."]
    #[doc = " This is all per-channel."]
    pub fn speex_resampler_process_interleaved_int(
        st: *mut SpeexResamplerState,
        in_: *const spx_int16_t,
        in_len: *mut spx_uint32_t,
        out: *mut spx_int16_t,
        out_len: *mut spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set (change) the input/output sampling rates (integer value)."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param in_rate Input sampling rate (integer number of Hz)."]
    #[doc = " @param out_rate Output sampling rate (integer number of Hz)."]
    pub fn speex_resampler_set_rate(
        st: *mut SpeexResamplerState,
        in_rate: spx_uint32_t,
        out_rate: spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current input/output sampling rates (integer value)."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param in_rate Input sampling rate (integer number of Hz) copied."]
    #[doc = " @param out_rate Output sampling rate (integer number of Hz) copied."]
    pub fn speex_resampler_get_rate(
        st: *mut SpeexResamplerState,
        in_rate: *mut spx_uint32_t,
        out_rate: *mut spx_uint32_t,
    );
}
extern "C" {
    #[doc = " Set (change) the input/output sampling rates and resampling ratio"]
    #[doc = " (fractional values in Hz supported)."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param ratio_num Numerator of the sampling rate ratio"]
    #[doc = " @param ratio_den Denominator of the sampling rate ratio"]
    #[doc = " @param in_rate Input sampling rate rounded to the nearest integer (in Hz)."]
    #[doc = " @param out_rate Output sampling rate rounded to the nearest integer (in Hz)."]
    pub fn speex_resampler_set_rate_frac(
        st: *mut SpeexResamplerState,
        ratio_num: spx_uint32_t,
        ratio_den: spx_uint32_t,
        in_rate: spx_uint32_t,
        out_rate: spx_uint32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current resampling ratio. This will be reduced to the least"]
    #[doc = " common denominator."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param ratio_num Numerator of the sampling rate ratio copied"]
    #[doc = " @param ratio_den Denominator of the sampling rate ratio copied"]
    pub fn speex_resampler_get_ratio(
        st: *mut SpeexResamplerState,
        ratio_num: *mut spx_uint32_t,
        ratio_den: *mut spx_uint32_t,
    );
}
extern "C" {
    #[doc = " Set (change) the conversion quality."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param quality Resampling quality between 0 and 10, where 0 has poor"]
    #[doc = " quality and 10 has very high quality."]
    pub fn speex_resampler_set_quality(
        st: *mut SpeexResamplerState,
        quality: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the conversion quality."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param quality Resampling quality between 0 and 10, where 0 has poor"]
    #[doc = " quality and 10 has very high quality."]
    pub fn speex_resampler_get_quality(
        st: *mut SpeexResamplerState,
        quality: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set (change) the input stride."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param stride Input stride"]
    pub fn speex_resampler_set_input_stride(st: *mut SpeexResamplerState, stride: spx_uint32_t);
}
extern "C" {
    #[doc = " Get the input stride."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param stride Input stride copied"]
    pub fn speex_resampler_get_input_stride(
        st: *mut SpeexResamplerState,
        stride: *mut spx_uint32_t,
    );
}
extern "C" {
    #[doc = " Set (change) the output stride."]
    #[doc = " @param st Resampler state"]
    #[doc = " @param stride Output stride"]
    pub fn speex_resampler_set_output_stride(st: *mut SpeexResamplerState, stride: spx_uint32_t);
}
extern "C" {
    #[doc = " Get the output stride."]
    #[doc = " @param st Resampler state copied"]
    #[doc = " @param stride Output stride"]
    pub fn speex_resampler_get_output_stride(
        st: *mut SpeexResamplerState,
        stride: *mut spx_uint32_t,
    );
}
extern "C" {
    #[doc = " Get the latency in input samples introduced by the resampler."]
    #[doc = " @param st Resampler state"]
    pub fn speex_resampler_get_input_latency(st: *mut SpeexResamplerState)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the latency in output samples introduced by the resampler."]
    #[doc = " @param st Resampler state"]
    pub fn speex_resampler_get_output_latency(
        st: *mut SpeexResamplerState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make sure that the first samples to go out of the resamplers don\'t have"]
    #[doc = " leading zeros. This is only useful before starting to use a newly created"]
    #[doc = " resampler. It is recommended to use that when resampling an audio file, as"]
    #[doc = " it will generate a file with the same length. For real-time processing,"]
    #[doc = " it is probably easier not to use this call (so that the output duration"]
    #[doc = " is the same for the first frame)."]
    #[doc = " @param st Resampler state"]
    pub fn speex_resampler_skip_zeros(st: *mut SpeexResamplerState) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a resampler so a new (unrelated) stream can be processed."]
    #[doc = " @param st Resampler state"]
    pub fn speex_resampler_reset_mem(st: *mut SpeexResamplerState) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the English meaning for an error code"]
    #[doc = " @param err Error code"]
    #[doc = " @return English string"]
    pub fn speex_resampler_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
